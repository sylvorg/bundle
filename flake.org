#+setuphere: yes
#+property: header-args:nix+ :tangle yes
#+property: header-args:diff+ :tangle yes

#+name: 49b87986-5ad9-41f2-ba20-b63599e596e7
#+begin_src emacs-lisp :var dir=""
(mapconcat (lambda (d) (concat "overlays.overlays." (file-name-base d))) (directory-files-recursively dir ".") " ")
#+end_src

* Description

#+begin_src nix
{ description = "Shared settings for our packages!";
#+end_src

* Inputs

#+begin_src nix
    inputs = {
        nixpkgs.url = github:NixOS/nixpkgs/<<channel(dotted='t)>>;
        flake-utils.url = github:numtide/flake-utils;
        flake-compat = {
            url = "github:edolstra/flake-compat";
            flake = false;
        };
    };
#+end_src

* Outputs

#+begin_src nix
    outputs = inputs@{ self, nixpkgs, flake-utils, ... }: with builtins; with flake-utils.lib; let
#+end_src

** Patch Nixpkgs Function

#+begin_src nix
        patch = {
            nixpkgs = let
                patches' = [ patches.bcachefs-module ];
            in {
                default = src: config: (import src config).applyPatches {
                    name = "defaultPatches";
                    inherit src;
                    patches = patches';
                };
                extras = src: config: patches: (import src config).applyPatches { name = "extraPatches"; inherit src patches; };
                both = src: config: patches: (import src config).applyPatches {
                    name = "bothPatches";
                    inherit src;
                    patches = patches' ++ patches;
                };
            };
            pkgs = {
                default = src: config: import (patch.nixpkgs.default src config) config;
                extras = src: config: patches: import (patch.nixpkgs.extras src config patches) config;
            };
        };
#+end_src

** Lib

With help from [[Henrik Lissner / hlissner][https://github.com/hlissner/dotfiles]]:

#+begin_src nix
        lib = nixpkgs.lib.extend (final: prev: { j = with final; let
            newLib = self: rec {
#+end_src

These are kept separately so that they're easier to debug:

#+begin_src nix
                mapAttrNames = func: mapAttrs' (n: v: nameValuePair (func n v) v);
                mif = {
                    list = optionals;
                    list' = optional;
                    set = optionalAttrs;
                    num = condition: value: if condition then value else 0;
                    null = condition: value: if condition then value else null;
                    str = optionalString;
                };
#+end_src

Adapted from [[https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L406][here]]:

#+begin_src nix
                genAttrNames = values: f: listToAttrs (map (v: nameValuePair (f v) v) values);
#+end_src

#+begin_src nix
                foldToSet = list: foldr (new: old: new // old) {} (filter isAttrs (flatten list));
                foldToSet' = list: foldr (new: old: recursiveUpdate new old) {} (filter isAttrs (flatten list));
                readDirExists = dir: mif.set (pathExists dir) (readDir dir);
                dirCon = let
                    ord = func: dir: filterAttrs func (if (isAttrs dir) then dir else (readDirExists dir));
                in rec {
                    attrs = {
                        dirs = ord (n: v: v == "directory");
                        others = ord (n: v: v != "directory");
                        files = ord (n: v: v == "regular");
                        sym = ord (n: v: v == "symlink");
                        unknown = ord (n: v: v == "unknown");
                    };
                    dirs = dir: attrNames (attrs.dirs dir);
                    others = dir: attrNames (attrs.others dir);
                    files = dir: attrNames (attrs.files dir);
                    sym = dir: attrNames (attrs.sym dir);
                    unknown = dir: attrNames (attrs.unknown dir);
                };
                has = {
                    prefix = string: any (flip hasPrefix string);
                    suffix = string: any (flip hasSuffix string);
                    infix = string: any (flip hasInfix string);
                };
                filters = {
                    has = {
                        attrs = list: attrs: let
                            l = unique (flatten list);
                        in foldToSet [
                            (filterAttrs (n: v: elem n l) attrs)
                            (genAttrNames (filter isDerivation l) (drv: drv.pname or drv.name))
                        ];
                        list = list: attrs: attrValues (filters.has.attrs list attrs);

                        # Roger, roger!
                        attr-attr = attrs: filterAttrs (n: v: elem n (attrNames attrs));

                    };
                    keep = {
                        prefix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: has.prefix n (toList keeping)) attrs);
                        suffix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: has.suffix n (toList keeping)) attrs);
                        infix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: has.infix n (toList keeping)) attrs);
                        elem = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: elem n (toList keeping)) attrs);
                        inherit (dirCon.attrs) dirs others files sym unknown;
                        readDir = {
                            dirs = {
                                prefix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "directory") then (has.prefix n (toList keeping)) else true) attrs);
                                suffix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "directory") then (has.suffix n (toList keeping)) else true) attrs);
                                infix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "directory") then (has.infix n (toList keeping)) else true) attrs);
                                elem = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "directory") then (elem n (toList keeping)) else true) attrs);
                            };
                            others = {
                                prefix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v != "directory") then (has.prefix n (toList keeping)) else true) attrs);
                                suffix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v != "directory") then (has.suffix n (toList keeping)) else true) attrs);
                                infix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v != "directory") then (has.infix n (toList keeping)) else true) attrs);
                                elem = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v != "directory") then (elem n (toList keeping)) else true) attrs);
                            };
                            files = {
                                prefix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "regular") then (has.prefix n (toList keeping)) else true) attrs);
                                suffix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "regular") then (has.suffix n (toList keeping)) else true) attrs);
                                infix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "regular") then (has.infix n (toList keeping)) else true) attrs);
                                elem = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "regular") then (elem n (toList keeping)) else true) attrs);
                            };
                            sym = {
                                prefix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "symlink") then (has.prefix n (toList keeping)) else true) attrs);
                                suffix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "symlink") then (has.suffix n (toList keeping)) else true) attrs);
                                infix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "symlink") then (has.infix n (toList keeping)) else true) attrs);
                                elem = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "symlink") then (elem n (toList keeping)) else true) attrs);
                            };
                            unknown = {
                                prefix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "unknown") then (has.prefix n (toList keeping)) else true) attrs);
                                suffix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "unknown") then (has.suffix n (toList keeping)) else true) attrs);
                                infix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "unknown") then (has.infix n (toList keeping)) else true) attrs);
                                elem = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if (v == "unknown") then (elem n (toList keeping)) else true) attrs);
                            };
                            static = {
                                prefix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if ((v == "regular") || (v == "unknown")) then (has.prefix n (toList keeping)) else true) attrs);
                                suffix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if ((v == "regular") || (v == "unknown")) then (has.suffix n (toList keeping)) else true) attrs);
                                infix = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if ((v == "regular") || (v == "unknown")) then (has.infix n (toList keeping)) else true) attrs);
                                elem = keeping: attrs: if ((keeping == []) || (keeping == "")) then attrs else (filterAttrs (n: v: if ((v == "regular") || (v == "unknown")) then (elem n (toList keeping)) else true) attrs);
                            };
                        };
                    };
                    remove = {
                        prefix = ignores: filterAttrs (n: v: ! (has.prefix n (toList ignores)));
                        suffix = ignores: filterAttrs (n: v: ! (has.suffix n (toList ignores)));
                        infix = ignores: filterAttrs (n: v: ! (has.infix n (toList ignores)));
                        elem = ignores: filterAttrs (n: v: ! (elem n (toList ignores)));
                        dirs = dirCon.attrs.others;
                        files = filterAttrs (n: v: v != "regular");
                        others = dirCon.attrs.dirs;
                        sym = filterAttrs (n: v: v != "symlink");
                        unknown = filterAttrs (n: v: v != "unknown");
                        readDir = {
                            dirs = {
                                prefix = ignores: filterAttrs (n: v: (! (has.prefix n (toList ignores))) && (v == "directory"));
                                suffix = ignores: filterAttrs (n: v: (! (has.suffix n (toList ignores))) && (v == "directory"));
                                infix = ignores: filterAttrs (n: v: (! (has.infix n (toList ignores))) && (v == "directory"));
                                elem = ignores: filterAttrs (n: v: (! (elem n (toList ignores))) && (v == "directory"));
                            };
                            others = {
                                prefix = ignores: filterAttrs (n: v: if (v != "directory") then (! (has.prefix n (toList ignores))) else true);
                                suffix = ignores: filterAttrs (n: v: if (v != "directory") then (! (has.suffix n (toList ignores))) else true);
                                infix = ignores: filterAttrs (n: v: if (v != "directory") then (! (has.infix n (toList ignores))) else true);
                                elem = ignores: filterAttrs (n: v: if (v != "directory") then (! (elem n (toList ignores))) else true);
                            };
                            files = {
                                prefix = ignores: filterAttrs (n: v: if (v == "regular") then (! (has.prefix n (toList ignores))) else true);
                                suffix = ignores: filterAttrs (n: v: if (v == "regular") then (! (has.suffix n (toList ignores))) else true);
                                infix = ignores: filterAttrs (n: v: if (v == "regular") then (! (has.infix n (toList ignores))) else true);
                                elem = ignores: filterAttrs (n: v: if (v == "regular") then (! (elem n (toList ignores))) else true);
                            };
                            sym = {
                                prefix = ignores: filterAttrs (n: v: if (v == "symlink") then (! (has.prefix n (toList ignores))) else true);
                                suffix = ignores: filterAttrs (n: v: if (v == "symlink") then (! (has.suffix n (toList ignores))) else true);
                                infix = ignores: filterAttrs (n: v: if (v == "symlink") then (! (has.infix n (toList ignores))) else true);
                                elem = ignores: filterAttrs (n: v: if (v == "symlink") then (! (elem n (toList ignores))) else true);
                            };
                            unknown = {
                                prefix = ignores: filterAttrs (n: v: if (v == "unknown") then (! (has.prefix n (toList ignores))) else true);
                                suffix = ignores: filterAttrs (n: v: if (v == "unknown") then (! (has.suffix n (toList ignores))) else true);
                                infix = ignores: filterAttrs (n: v: if (v == "unknown") then (! (has.infix n (toList ignores))) else true);
                                elem = ignores: filterAttrs (n: v: if (v == "unknown") then (! (elem n (toList ignores))) else true);
                            };
                            static = {
                                prefix = keeping: filterAttrs (n: v: if ((v == "regular") || (v == "unknown")) then (! (has.prefix n (toList keeping))) else true);
                                suffix = keeping: filterAttrs (n: v: if ((v == "regular") || (v == "unknown")) then (! (has.suffix n (toList keeping))) else true);
                                infix = keeping: filterAttrs (n: v: if ((v == "regular") || (v == "unknown")) then (! (has.infix n (toList keeping))) else true);
                                elem = keeping: filterAttrs (n: v: if ((v == "regular") || (v == "unknown")) then (! (elem n (toList keeping))) else true);
                            };
                        };
                    };
                };
                imports = rec {
                    name = {
                        file,
                        suffix ? ".nix",
                    }: let
                        base-file = baseNameOf (toString file);
                    in if (isInt suffix) then (let
                        hidden = hasPrefix "." base-file;
                        split-file = remove "" (splitString "." base-file);
                    in if (hidden && ((length split-file) == 1)) then base-file
                    else concatStringsSep "." (take ((length split-file) - suffix) split-file)) else (removeSuffix suffix base-file);
                    list = args@{
                        dir,
                        idir ? dir,
                        ignores ? {},
                        iter ? 0,
                        keep ? false,
                        keeping ? {},
                        local ? false,
                        file ? { prefix = { pre = ""; post = ""; }; suffix = ""; },
                        recursive ? false,
                        root ? false,
                        names ? false,
                        suffix ? ".nix",
                    }: let
                        func = dir: let
                            stringDir = toString dir;
                            stringyDir = toString idir;
                            fk = filters.keep;
                            fr = filters.remove;
                            pre-orders = flatten [
                                (optional (keeping.files or false) fk.files)
                                (optional (keeping.unknown or false) fk.unknown)
                                (fk.prefix (keeping.prefix or []))
                                (fk.infix (keeping.infix or []))
                                (fk.readDir.files.suffix (keeping.suffix or []))
                                (fk.readDir.files.elem (keeping.elem or []))
                                (fk.readDir.unknown.suffix (keeping.suffix or []))
                                (fk.readDir.unknown.elem (keeping.elem or []))
                                (fk.readDir.static.suffix (keeping.suffix or []))
                                (fk.readDir.static.elem (keeping.elem or []))
                                (optional (ignores.files or false) fr.files)
                                (optional (ignores.unknown or false) fr.unknown)
                                (fr.prefix (ignores.prefix or []))
                                (fr.infix (ignores.infix or []))
                                (fr.readDir.files.suffix (ignores.suffix or []))
                                (fr.readDir.files.elem (ignores.elem or []))
                                (fr.readDir.unknown.suffix (ignores.suffix or []))
                                (fr.readDir.unknown.elem (ignores.elem or []))
                                (fr.readDir.static.suffix (ignores.suffix or []))
                                (fr.readDir.static.elem (ignores.elem or []))
                            ];
                            orders = flatten [
                                (optional (keeping.dirs or false) fk.dirs)
                                (optional (keeping.others or false) fk.others)
                                (optional (keeping.sym or false) fk.sym)
                                (fk.suffix (keeping.suffix or []))
                                (fk.elem (keeping.elem or []))
                                (optional (ignores.dirs or false) fr.dirs)
                                (optional (ignores.others or false) fr.others)
                                (optional (ignores.sym or false) fr.sym)
                                (fr.suffix (ignores.suffix or []))
                                (fr.elem (ignores.elem or []))
                            ];
                            pipe-list = flatten [
                                (mapAttrNames (n: v: pipe "${removePrefix stringyDir stringDir}/${n}" [
                                    (splitString "/")
                                    (remove "")
                                    (concatStringsSep "/")
                                ]))
                                pre-orders
                            ];
                            items = let
                                filtered-others = pipe (dirCon.attrs.others dir) pipe-list;
                                filtered-dirs = pipe (dirCon.attrs.dirs dir) (flatten [
                                    pipe-list
                                    (optionals recursive (mapAttrsToList (n: v: list (args // { dir = "${stringyDir}/${n}"; inherit idir; iter = iter + 1; }))))
                                ]);
                            in foldToSet [ filtered-others filtered-dirs ];
                            process = s: pipe s (flatten [
                                pipe-list
                                orders
                                (if names then (mapAttrNames (file: v: name { inherit suffix file; })) else [
                                    (mapAttrNames (n: v: (file.prefix.pre or "") + n))
                                    (mapAttrNames (n: v: if keep then n
                                                        else if local then "./${n}"
                                                        else if root then "/${n}"
                                                        else "${stringDir}/${n}"))
                                    (mapAttrNames (n: v: (file.prefix.post or "") + n + (file.suffix or "")))
                                ])
                                attrNames
                            ]);
                        in if (iter == 0) then (process items) else items;
                    in flatten (map func (toList dir));
                    set = args@{
                        call ? null,
                        dir,
                        extrargs ? {},
                        suffix ? ".nix",
                        ...
                    }: listToAttrs (map (file: nameValuePair
                        (name { inherit file suffix; })
                        (if (call != null) then (call.callPackage file extrargs)
                        else if (extrargs == {}) then (import file)
                        else (import file extrargs))
                    ) (list (filterAttrs (n: v: ! (elem n [ "call" "extrargs" ])) args)));
                    overlaySet = args@{
                        call ? null,
                        dir,
                        extrargs ? {},
                        func ? null,
                        suffix ? ".nix",
                        ...
                    }: listToAttrs (map (file: let
                        filename = name { inherit file suffix; };
                    in nameValuePair
                        filename
                        (if (func != null) then (func file)
                        else if ((isInt call) && (call == 1)) then (final: prev: { "${filename}" = final.callPackage file extrargs; })
                        else if ((isInt call) && (call == 0)) then (final: prev: { "${filename}" = prev.callPackage file extrargs; })
                        else if (call != null) then (final: prev: { "${filename}" = call.callPackage file extrargs; })
                        else if (extrargs == {}) then (import file)
                        else (import file extrargs))
                    ) (list (filterAttrs (n: v: ! (elem n [ "call" "extrargs" "func" ])) (recursiveUpdate args { ignores.dirs = true; }))));
                };
#+end_src

#+begin_src nix
                update = {
                    python = rec {
#+end_src

Adapted from [[https://discourse.nixos.org/t/how-to-add-custom-python-package/536/4][here]]:

#+begin_src nix
                        python = rec {
                            base = pv: prev: attrs: { "${pv}" = prev.${pv}.override (super: {
                                packageOverrides = lib.composeExtensions super.packageOverrides or (final: prev: {}) (new: old: attrs);
                            }); };
                            two = base attrs.versions.python.two;
                            three = base attrs.versions.python.three;
                        };
                        callPython = rec {
                            base = pv: file: final: prev: python.base pv prev { "${imports.name { inherit file; }}" = final.${pv}.pkgs.callPackage file {}; };
                            two = base attrs.versions.python.two;
                            three = base attrs.versions.python.three;
                        };
                        callPython' = rec {
                            base = pv: name: pkg: final: prev: python.base pv prev { "${name}" = final.${pv}.pkgs.callPackage pkg {}; };
                            two = base attrs.versions.python.two;
                            three = base attrs.versions.python.three;
                        };
#+end_src

#+begin_src nix
                        package = rec {
                            base = pv: prev: pkg: func: python.base pv prev { "${pkg}" = prev.${pv}.pkgs.${pkg}.overridePythonAttrs func; };
                            two = base attrs.versions.python.two;
                            three = base attrs.versions.python.three;
                        };
                        packages = rec {
                            base = pv: final: prev: dir: python.base pv prev (imports.set { call = final.${pv}.pkgs; inherit dir; ignores.elem = dirCon.dirs dir; });
                            two = base attrs.versions.python.two;
                            three = base attrs.versions.python.three;
                        };
                    };
                };

                zipToSet = names: values: listToAttrs (
                    map (nv: nameValuePair nv.fst nv.snd) (let hasAttrs = any isAttrs values; in zipLists (
                        if hasAttrs then names else (sort lessThan names)
                    ) (
                        if hasAttrs then values else (sort lessThan values)
                    ))
                );
                toCapital = string: concatImapStrings (
                    i: v: if (i == 1) then (toUpper v) else v
                ) (stringToCharacters string);

                # foldr func end list
                sequence = foldr deepSeq;

                attrs = rec {
                    configs = {
                        nixpkgs = {
                            allowUnfree = true;
                            allowBroken = true;
                            allowUnsupportedSystem = true;
                            # preBuild = ''
                            #     makeFlagsArray+=(CFLAGS="-w")
                            #     buildFlagsArray+=(CC=cc)
                            # '';
                            permittedInsecurePackages = [
                                "python2.7-cryptography-2.9.2"
                            ];
                        };
                    };
                    platforms = {
                        arm = [ "aarch64-linux" "armv7l-linux" "armv6l-linux" ];
                        imd = [ "i686-linux" "x86_64-linux" ];
                    };
                    versions = {
                        python = rec {
                            two' = "7";
                            three' = "10";
                            two = "python2${two'}";
                            three = "python3${three'}";
                        };
                    };
                };

                inherit patch;
            };
        in makeExtensible newLib; });
#+end_src

** callPackages

#+begin_src nix
        callPackages = {
#+end_src

*** settings

#+begin_src nix
            settings = { stdenv }: stdenv.mkDerivation rec {
                pname = "settings";
                version = "1.0.0.0";
                src = ./.;
                phases = [ "installPhase" ];
                installPhase = ''
                    mkdir --parents $out
                    cp -r $src/bin $out/bin
                    chmod +x $out/bin/*
                '';
                meta.mainprogram = "org-tangle";
            };
#+end_src

*** sysget.nix

#+begin_src
            sysget = { stdenv, fetchFromGitHub, lib, installShellFiles }: let
                owner = "emilengler";
            in stdenv.mkDerivation rec {
                pname = "sysget";
                version = "2.3";
                src = fetchFromGitHub {
                    inherit owner;
                    repo = pname;
                    rev = "v${version}";
                    sha256 = "0zax8qf4pzglx0rsnv57xvh9wrjh479ymr70ja2nvv22k16gfx1r";
                };
                buildInputs = [ installShellFiles ];
                nativeBuildInputs = buildInputs;
                installPhase = ''
                    mkdir -p $out/bin
                    cp ${pname} $out/bin/
                    installManPage contrib/man/${pname}.8
                    installShellCompletion --bash contrib/${pname}.bash-completion
                '';
                meta = {
                    description = "One package manager to rule them all";
                    homepage = "https://github.com/${owner}/${pname}";
                    license = lib.licenses.gpl3;
                };
            };
#+end_src

*** pacapt.nix

#+begin_src nix
            pacapt = { stdenv, fetchFromGitHub }: let
                owner = "icy";
            in stdenv.mkDerivation rec {
                pname = "pacapt";
                version = "3.0.7";
                src = fetchFromGitHub {
                    inherit owner;
                    repo = pname;
                    rev = "v${version}";
                    sha256 = "07zjdhn21rnacv2i59h91q4ykbqvsab4pmgqv8c952fzi3m5gjk4";
                };
                installPhase = ''
                    mkdir --parents $out/bin
                    cp $src/${pacapt} $out/bin/
                    chmod 755 $out/bin/*
                '';
                meta = {
                    description = "An ArchLinux's pacman-like shell wrapper for many package managers. 56KB and run anywhere.";
                    homepage = "https://github.com/${owner}/${pname}";
                };
            };
#+end_src

*** flk.nix

#+begin_src nix
            flk = { stdenv, fetchgit, lib }: let
                owner = "chr15m";
            in stdenv.mkDerivation rec {
                pname = "flk";
                version = "1.0.0.0";
                src = fetchgit {
                    url = "https://github.com/${owner}/${pname}.git";
                    rev = "46a88bdb461dda336d5aca851c16d938e05304dc";
                    sha256 = "sha256-NAhWe0O1K3LOdIwYNOHfkBzkGm+h0wckpsCuY/lY/+8=";
                    deepClone = true;
                };
                installPhase = ''
                    mkdir --parents $out/bin
                    cp ./docs/${pname} $out/bin/
                '';
                meta = {
                    description = "A LISP that runs wherever Bash is";
                    homepage = "https://github.com/${owner}/${pname}";
                    license = lib.licenses.mpl20;
                };
            };
#+end_src

*** mdsh.nix

#+begin_src nix
            mdsh = { stdenv, fetchFromGitHub, lib }: let
                owner = "bashup";
            in stdenv.mkDerivation rec {
                pname = "mdsh";
                version = "1.0.0.0";
                src = fetchFromGitHub {
                    inherit owner;
                    repo = pname;
                    rev = "7e7af618a341eebd50e7825b062bc192079ad5fc";
                    sha256 = "1wg5iy1va2fl843rish2q1kif818cz8mnhwmg88ir5p364fc2kcp";
                };
                installPhase = ''
                    mkdir --parents $out/bin
                    cp $src/bin/${pname} $out/bin/
                '';
                meta = {
                    description = "Multi-lingual, Markdown-based Literate Programming... in run-anywhere bash";
                    homepage = "https://github.com/${owner}/${pname}";
                    license = lib.licenses.mit;
                };
            }
#+end_src

*** poetry2setup

#+begin_src nix
            poetry2setup = { lib, Python, fetchFromGitHub, gawk }: Python.pkgs.buildPythonApplication rec {
                pname = "poetry2setup";
                version = "1.0.0";
                format = "pyproject";

                src = fetchFromGitHub {
                    owner = "abersheeran";
                    repo = pname;
                    rev = "6d3345f488fda4d0f6eed1bd3438ea6207e55e3a";
                    sha256 = "07z776ikj37whhx7pw1f3pwp25w04aw22vwipjjmvi8c642qxni4";
                };

                propagatedBuildInputs = with Python.pkgs; [ poetry-core ];

                buildInputs = with Python.pkgs; [ poetry-core ];

                installPhase = ''
                    mkdir --parents $out/bin
                    cp $src/${pname}.py $out/bin/${pname}
                    chmod +x $out/bin/${pname}
#+end_src

Adapted from [[https://unix.stackexchange.com/users/28765/rudimeier][rudimeier's]] answer [[https://unix.stackexchange.com/a/313025/270053][here]]:

#+begin_src nix
                    ${gawk}/bin/awk -i inplace 'BEGINFILE{print "#!/usr/bin/env python3"}{print}' $out/bin/${pname}
#+end_src

#+begin_src nix
                '';

                postFixup = "wrapProgram $out/bin/${pname} $makeWrapperArgs";

                makeWrapperArgs = [ "--prefix PYTHONPATH : ${placeholder "out"}/lib/${Python.pkgs.python.libPrefix}/site-packages" ];

                meta = {
                    description = "Convert python-poetry(pyproject.toml) to setup.py.";
                    homepage = "https://github.com/abersheeran/${pname}";
                    license = lib.licenses.mit;
                };
            };
#+end_src

*** Python

#+begin_src nix
            python = {
#+end_src

**** Two

#+begin_src nix
                two = {
#+end_src

***** End of two

#+begin_src nix
                };
#+end_src

**** Three

#+begin_src nix
                three = {
#+end_src

***** autoslot

#+begin_src nix
                    autoslot = { lib, buildPythonPackage, fetchFromGitHub, pytestCheckHook, flit }: let
                        owner = "cjrh";
                    in buildPythonPackage rec {
                        pname = "autoslot";
                        version = "2021.10.1";
                        format = "pyproject";
                        src = fetchFromGitHub {
                            inherit owner;
                            repo = pname;
                            rev = "a36ea378136bc7dfdc11f3f950186f6ed8bee8c5";
                            sha256 = "1dds9dwf5bqxi84s1fzcdykiqgcc1iq3rh6p76wjz6h7cb451h08";
                        };
                        buildInputs = [ flit ];
                        nativeBuildInputs = buildInputs;
                        checkInputs = [ pytestCheckHook ];
                        pythonImportsCheck = [ pname ];
                        meta = {
                            description = "Automatic __slots__ for your Python classes";
                            homepage = "https://github.com/${owner}/${pname}";
                            license = lib.licenses.asl20;
                        };
                    };
#+end_src

***** magicattr

#+begin_src nix
                    magicattr = { lib, buildPythonPackage, fetchFromGitHub, pytestCheckHook, flit }: let
                        owner = "frmdstryr";
                    in buildPythonPackage rec {
                        pname = "magicattr";
                        version = "0.1.6";
                        src = fetchFromGitHub {
                            inherit owner;
                            repo = pname;
                            rev = "15ae93def3693661066624c9d760b26f6e205199";
                            sha256 = "1pq1xrlaadkdic9xlig8rv97zkymqgbikparfrdpdfifj19md6ql";
                        };
                        doCheck = false;
                        pythonImportsCheck = [ pname ];
                        meta = {
                            description = "A getattr and setattr that works on nested objects, lists, dicts, and any combination thereof without resorting to eval";
                            homepage = "https://github.com/${owner}/${pname}";
                            license = lib.licenses.mit;
                        };
                    };
#+end_src

***** backtrace

#+begin_src nix
                    backtrace = { lib, buildPythonPackage, fetchFromGitHub, pytestCheckHook, colorama }: let
                        owner = "nir0s";
                    in buildPythonPackage rec {
                        pname = "backtrace";
                        version = "0.2.1";
                        src = fetchFromGitHub {
                            inherit owner;
                            repo = pname;
                            rev = "a1f75c956f669a6175088693802d5392e6bd7e51";
                            sha256 = "1i3xj04zxz9vi57gbkmnnyh9cypf3bm966ic685s162p1xhnz2qp";
                        };
                        propagatedBuildInputs = [ colorama ];
                        checkInputs = [ pytestCheckHook ];
                        pythonImportsCheck = [ pname ];
                        meta = {
                            description = "Makes Python tracebacks human friendly";
                            homepage = "https://github.com/${owner}/${pname}";
                            license = lib.licenses.asl20;
                        };
                    };
#+end_src

***** End of three

#+begin_src nix
                };
#+end_src

**** Xonsh

#+begin_src nix
                xonsh = {
#+end_src

***** xontrib-readable-traceback

#+begin_src nix
                    xontrib-readable-traceback = { lib, buildPythonPackage, fetchPypi, colorama, backtrace }: buildPythonPackage rec {
                        pname = "xontrib-readable-traceback";
                        version = "0.3.2";
                        src = fetchPypi {
                            inherit pname version;
                            sha256 = "sha256-1D/uyiA3A1dn9IPakjighckZT5Iy2WOMroBkLMp/FZM=";
                        };
                        propagatedBuildInputs = [ colorama backtrace ];
                        meta = {
                            description = "xonsh readable traceback";
                            homepage = "https://github.com/vaaaaanquish/${pname}";
                            license = lib.licenses.mit;
                        };
                    };
#+end_src

***** xonsh-autoxsh

#+begin_src nix
                    xonsh-autoxsh = { lib, buildPythonPackage, fetchPypi }: buildPythonPackage rec {
                        pname = "xonsh-autoxsh";
                        version = "0.3";
                        src = fetchPypi {
                            inherit pname version;
                            sha256 = "sha256-qwXbNbQ5mAwkZ4N+htv0Juw2a3NF6pv0XpolLIQfIe4=";
                        };
                        meta = {
                            description = "Automatically execute scripts for directories in Xonsh Shell.";
                            homepage = "https://github.com/Granitosaurus/${pname}";
                            license = lib.licenses.mit;
                        };
                    };
#+end_src

***** xonsh-direnv

#+begin_src nix
                    xonsh-direnv = { lib, buildPythonPackage, fetchPypi }: buildPythonPackage rec {
                        pname = "xonsh-direnv";
                        version = "1.5.0";
                        src = fetchPypi {
                            inherit pname version;
                            sha256 = "sha256-OLjtGD2lX4Yf3aHrxCWmAbSPZnf8OuVrBu0VFbsna1Y=";
                        };
                        meta = {
                            description = "xonsh extension for using direnv";
                            homepage = "https://github.com/Granitosaurus/${pname}";
                            license = lib.licenses.mit;
                        };
                    };
#+end_src

***** xontrib-pipeliner

#+begin_src nix
                    xontrib-pipeliner = { lib, buildPythonPackage, fetchPypi, six }: buildPythonPackage rec {
                        pname = "xontrib-pipeliner";
                        version = "0.3.4";
                        src = fetchPypi {
                            inherit pname version;
                            sha256 = "sha256-f8tUjPEQYbycq1b3bhXwPU2YF9fkp1URqDDLH2CeNpo=";
                        };
                        propagatedBuildInputs = [ six ];
                        postPatch = ''
                            substituteInPlace setup.py --replace "'xonsh', " ""
                        '';
                        meta = {
                            description = "Let your pipe lines flow thru the Python code in xonsh.";
                            homepage = "https://github.com/anki-code/${pname}";
                            license = lib.licenses.mit;
                        };
                    };
#+end_src

***** xontrib-sh

#+begin_src nix
                    xontrib-sh = { lib, buildPythonPackage, fetchPypi }: buildPythonPackage rec {
                        pname = "xontrib-sh";
                        version = "0.3.0";
                        src = fetchPypi {
                            inherit pname version;
                            sha256 = "sha256-eV++ZuopnAzNXRuafXXZM7tmcay1NLBIB/U+SVrQV+U=";
                        };
                        meta = {
                            description = "Paste and run commands from bash, zsh, fish, tcsh in xonsh shell.";
                            homepage = "https://github.com/anki-code/${pname}";
                            license = lib.licenses.mit;
                        };
                    };
#+end_src

***** End of Xonsh

#+begin_src nix
                };
#+end_src

**** End of Python

#+begin_src nix
            };
#+end_src

*** End of callPackages

#+begin_src nix
        };
#+end_src

** Patches

#+begin_src nix
        patches = {
#+end_src

*** bcachefs-module

#+begin_src nix
            bcachefs-module = toFile "bcachefs-module.patch" ''
#+end_src

#+begin_src diff
diff --git a/nixos/modules/tasks/filesystems/bcachefs.nix b/nixos/modules/tasks/filesystems/bcachefs.nix
index 5fda24adb97..897ddf03927 100644
--- a/nixos/modules/tasks/filesystems/bcachefs.nix
+++ b/nixos/modules/tasks/filesystems/bcachefs.nix
@@ -45,7 +45,7 @@ in
       system.fsPackages = [ pkgs.bcachefs-tools ];
 
       # use kernel package with bcachefs support until it's in mainline
-      boot.kernelPackages = pkgs.linuxPackages_testing_bcachefs;
+      # boot.kernelPackages = pkgs.linuxPackages_testing_bcachefs;
     }
 
     (mkIf ((elem "bcachefs" config.boot.initrd.supportedFilesystems) || (bootFs != {})) {
#+end_src

#+begin_src nix
            '';
#+end_src

*** licenses

#+begin_src nix
            licenses = toFile "licenses.patch" ''
#+end_src

#+begin_src diff
diff --git a/lib/licenses.nix b/lib/licenses.nix
index 4fa6d6abc7a..198b570e0ae 100644
--- a/lib/licenses.nix
+++ b/lib/licenses.nix
@@ -690,6 +690,11 @@ in mkLicense lset) ({
     fullName = "OpenSSL License";
   };
 
+  oreo = {
+    fullName = "Oreo Public License";
+    free = true;
+  };
+
   osl2 = {
     spdxId = "OSL-2.0";
     fullName = "Open Software License 2.0";
#+end_src

#+begin_src nix
            '';
#+end_src

*** python

#+begin_src nix
            python = toFile "python.patch" ''
#+end_src

#+begin_src diff
diff --git a/pkgs/top-level/aliases.nix b/pkgs/top-level/aliases.nix
index 7b9c55ee702..4c86533cad5 100644
--- a/pkgs/top-level/aliases.nix
+++ b/pkgs/top-level/aliases.nix
@@ -1154,10 +1154,10 @@ mapAliases ({
   pyrex095 = throw "pyrex has been removed from nixpkgs as the project is still stuck on python2"; # Added 2022-01-12
   pyrex096 = throw "pyrex has been removed from nixpkgs as the project is still stuck on python2"; # Added 2022-01-12
   pyrit = throw "pyrit has been removed from nixpkgs as the project is still stuck on python2"; # Added 2022-01-01
-  python = python2; # Added 2022-01-11
+  python = python3; # Added 2022-01-11
   python-swiftclient = swiftclient; # Added 2021-09-09
   python2nix = throw "python2nix has been removed as it is outdated. Use e.g. nixpkgs-pytools instead"; # Added 2021-03-08
-  pythonFull = python2Full; # Added 2022-01-11
+  pythonFull = python3Full; # Added 2022-01-11
   pythonPackages = python.pkgs; # Added 2022-01-11
 
   ### Q ###
diff --git a/pkgs/top-level/all-packages.nix b/pkgs/top-level/all-packages.nix
index 1803508bdd4..da416ccaea6 100644
--- a/pkgs/top-level/all-packages.nix
+++ b/pkgs/top-level/all-packages.nix
@@ -14502,7 +14502,7 @@ with pkgs;
   # available as `pythonPackages.tkinter` and can be used as any other Python package.
   # When switching these sets, please update docs at ../../doc/languages-frameworks/python.md
   python2 = python27;
-  python3 = python39;
+  python3 = python310;
 
   # pythonPackages further below, but assigned here because they need to be in sync
   python2Packages = dontRecurseIntoAttrs python27Packages;
#+end_src

#+begin_src nix
            '';
#+end_src

*** End of patches

#+begin_src nix
        };
#+end_src

** Overlays
*** Python Overlays

#+begin_src nix
        pythonOverlays = with lib; rec {
            python2 = j.foldToSet [
                (mapAttrs (n: v: j.update.python.callPython'.two n v) callPackages.python.two)
            ];
            python3 = let
                update = j.update.python.package.three;
            in j.foldToSet [
                {
                    hy = final: prev: update prev "hy" (old: rec {
                        version = "0.24.0";
                        src = final.fetchFromGitHub {
                            owner = "hylang";
                            repo = old.pname;
                            rev = version;
                            sha256 = "1s458ymd9g3s8k2ccc300jr4w66c7q3vhmhs9z3d3a4qg0xdhs9y";
                        };
                        postPatch = ''substituteInPlace setup.py --replace "\"funcparserlib ~= 1.0\"," ""'' + (old.postPatch or "");
                        disabledTestPaths = [ "tests/test_bin.py" ] ++ (old.disabledTestPaths or []);
                    });
                    hyrule = final: prev: update prev "hyrule" (old: rec {
                        version = "0.2";
                        src = final.fetchFromGitHub {
                            owner = "hylang";
                            repo = old.pname;
                            rev = version;
                            sha256 = "08w4q8s1hrnjqsqvs70adx90nqfij6iyyb4fzfffrrw2mwkf10gx";
                        };
                        postPatch = ''substituteInPlace setup.py --replace "'hy == 0.24.0'," ""'' + (old.postPatch or "");
                    });
                    flit = final: prev: update prev "flit" (old: with final; let newInputs = [ git ]; in {
                        buildInputs = newInputs ++ (old.buildInputs or []);
                        nativeBuildInputs = newInputs ++ (old.nativeBuildInputs or []);
                        disabledTestPaths = [
                            "tests/test_sdist.py"
                            "tests/test_upload.py"
                        ] ++ (old.disabledTestPaths or []);
                    });
                }
                (mapAttrs (n: v: j.update.python.callPython'.three n v) callPackages.python.three)
            ];
            python = python3;
            xonsh = j.foldToSet [
                (mapAttrs (n: v: j.update.python.callPython'.three n v) callPackages.python.xonsh)
            ];
        };
#+end_src

*** All Overlays

#+begin_src nix
        overlays = with lib; rec {
            overlays = let
                calledPackages = mapAttrs (n: v: final: prev: { "${n}" = final.callPackage v {}; }) (filterAttrs (n: v: isFunction v) callPackages);
                overlay = final: prev: { inherit (calledPackages) settings; };
            in j.foldToSet [
                pythonOverlays.python2
                pythonOverlays.python3
                pythonOverlays.xonsh
                {
                    j = final: prev: { j.pkgs = mapAttrs (n: v: patch.pkgs.default v (make.nixpkgset.default system))
                                                         (filterAttrs (n: v: (hasPrefix "nixos-" n) || (hasPrefix "release-" n)) inputs); };
                    lib = final: prev: { inherit lib; };;
                    default = overlay;
#+end_src

# TODO: test out using ~python~ instead of ~Python~

Note: This was giving ~error: attempt to call something which is not a function but a set~ because I was
importing the overlay file with an empty set in ~lib.j.imports.set~, i.e. ~import file extrargs~,
when I should have been importing just the file using ~import file~.

#+begin_src nix
                    Python = final: prev: rec {
                        Python2 = final.${j.attrs.versions.python.two};
                        Python2Packages = Python2.pkgs;
                        Python3 = final.${j.attrs.versions.python.three};
                        Python3Packages = Python3.pkgs;
                        Python = Python3;
                        PythonPackages = Python3Packages;
                    };
#+end_src

#+begin_src nix
                }
                calledPackages
            ];
            inherit overlay;
            defaultOverlay = overlay;
        };
#+end_src

** Make

#+begin_src nix
        make = system: pkgs: with lib; rec {
            app = drv: { type = "app"; program = "${drv}${drv.passthru.exePath or "/bin/${drv.meta.mainprogram or drv.executable or drv.pname or drv.name}"}"; };
            xonsh = pkglist: pname: let
                python3Packages = pkgs.Python3.pkgs;
            in (pkgs.xonsh.override { inherit python3Packages; }).overridePythonAttrs (old: {
                propagatedBuildInputs = j.filters.has.list [
                    pkglist
                    pname
                    (old.propagatedBuildInputs or [])
                ] python3Packages;
            });
            withPackages = {
                python = j.foldToSet (flatten [
                    (map (python: (listToAttrs (map (pkg: nameValuePair "${python}-${pkg}" (pkglist: pname: pkgs.${j.toCapital python}.withPackages (ppkgs: j.filters.has.list [
                        pkg
                        pkglist
                        pname
                    ] ppkgs))) (attrNames pythonOverlays.${python})))) [ "python" "python2" "python3" ])
                    (map (os: (listToAttrs (map (pkg: nameValuePair "xonsh-${pkg}" (pkglist: xonsh (flatten [ pkg pkglist ]))) (attrNames pythonOverlays.${os})))) [ "python3" "xonsh" ])
                    (listToAttrs (map (pkg: nameValuePair "xonsh-${pkg}" (pkglist: xonsh (flatten [ pkg pkglist ]))) (attrNames pythonOverlays.xonsh)))
                    (listToAttrs (map (python: nameValuePair python (pkglist: pname: pkgs.${j.toCapital python}.withPackages (ppkgs: j.filters.has.list [
                        (attrNames pythonOverlays.${python})
                        pkglist
                        pname
                    ] ppkgs))) [ "python" "python2" "python3" ]))
                    { xonsh = pkglist: xonsh (flatten [ (attrNames pythonOverlays.xonsh) pkglist ]); }
                ]);
            };
            bases = {
                python = {
                    buildInputs = with pkgs; [ git poetry2setup ];
                    shells = pkgs.mkShell { inherit (bases) buildInputs; };
                };
            };
            buildInputs = {
                python = mapAttrs (n: v: pkglist: ppkglist: pname: unique (flatten [
                    bases.python.buildInputs
                    (v ppkglist pname)
                    pkglist
                ])) withPackages.python;
            };
            shells = {
                python = j.foldToSet [
                    (mapAttrs (n: v: pkglist: ppkglist: pname: pkgs.mkShell {
                        buildInputs = v pkglist ppkglist pname;
                    }) buildInputs.python)
                ];
            };
        };
#+end_src

** Final Outputs

#+begin_src nix
    in with lib; j.foldToSet [
        (eachSystem allSystems (system: let
            legacyPackages = import nixpkgs { inherit system; config = j.attrs.configs.nixpkgs; overlays = attrValues overlays.overlays; };
            pkgs = legacyPackages;
            made = make pkgs;
        in rec {
            inherit legacyPackages pkgs;
            packages = flattenTree (j.foldToSet [
                (j.filters.has.attrs [
                    (subtractLists (attrNames nixpkgs.legacyPackages.${system}) (attrNames pkgs))
                    (attrNames overlays.overlays)
                ] pkgs)
                (mapAttrs (n: v: v [] null) made.withPackages)
            ]);
            package = packages.default;
            defaultPackage = package;
            apps = mapAttrs (n: v: made.app v) packages;
            app = apps.default;
            defaultApp = app;
            devShells = j.foldToSet [
                (mapAttrs (n: v: v [] [] null) made.shells.python)
            ];
            devShell = devShells.default;
            defaultdevShell = devShell;
        }))
        overlays
        { inherit make lib pythonOverlays; }
    ];
#+end_src

* End of flake.nix

#+begin_src nix
}
#+end_src
